import math
from timeit import default_timer as timer
#import matplotlib.pyplot as plt


# computes the distances between 2 cities
def compute_distance(city1, city2):
    # splits the x and y coordinates of each city
    x1, y1 = city1[1], city1[2]
    x2, y2 = city2[1], city2[2]
    return round(math.hypot(x2 - x1, y2 - y1))


# computes the distance of the whole tour
def compute_tour_distance(cities, tour):
    n = len(tour)
    total_distance = 0
    for i in range(n):
        city1 = cities[tour[i]]
        city2 = cities[tour[(i + 1) % n]]
        total_distance += compute_distance(city1, city2)
    return total_distance


# construct a partial tour. Starting from a given city, it iteratively selects the nearest unvisited city until half of the cities are included in the tour.
def nearest_neighbor(cities, start_city):
    n = len(cities)
    visited = [False] * n
    tour = [start_city]

    current_city = start_city
    visited[current_city] = True

    while len(tour) < (math.ceil(n // 2)): #checks if the tour is half of the cities
        min_distance = float("inf")
        nearest_city = None     #initializes the nearest city

        #calculates distance between current city and unvisted neighboring city
        for neighbor in range(n):
            if not visited[neighbor]:
                distance = compute_distance(cities[current_city], cities[neighbor])
                if distance < min_distance: #updates min distance if distance between city and neighboring city is shorter
                    min_distance = distance
                    nearest_city = neighbor

        tour.append(nearest_city)
        visited[nearest_city] = True
        current_city = nearest_city
    return tour

# 2 opt algorithm is applied on the tour generated by the nearest neighbor
def two_opt(cities, tour):
    isImproved = True
    n = len(tour)

    while isImproved:

        # set the isImproved flag to false
        isImproved = False
        for i in range(n - 2):

            #Calculate distance between first and second vertices
            distance1 = compute_distance(cities[tour[i]], cities[tour[(i + 1) % n]])
            #Calculate distance between third and fourth vertices
            distance2 = compute_distance(cities[tour[(i + 1) % n]], cities[tour[(i + 2) % n]])
            #Calculate distance between consecutive vertrices after the fourth vertex
            for k in range(i + 3, n):
                new_distance = (
                    compute_distance(cities[tour[i]], cities[tour[k]])
                    + compute_distance(
                        cities[tour[(i + 1) % n]], cities[tour[(k + 1) % n]]
                    )
                    + compute_distance(cities[tour[k]], cities[tour[(i + 2) % n]])
                    + compute_distance(cities[tour[(k - 1) % n]], cities[tour[i + 1]]) 
                    - distance1
                    - distance2
                    - compute_distance(cities[tour[k]], cities[tour[(k + 1) % n]])
                    - compute_distance(cities[tour[(k - 1) % n]], cities[tour[k]])
                )
                if new_distance < 0:
                    tour[i + 1], tour[k] = tour[k], tour[i + 1]
                    isImproved = True

    total_distance = compute_tour_distance(
        cities, tour
    )  # Include distance to return to starting city

    return tour, total_distance


# Read the input file
with open("test-input-1.txt", "r") as file:
    lines = file.readlines()

cities = []  # Initialize the cities list

for line in lines:
    values = list(
        map(int, line.strip().split())
    )  # splits to index, x-coord, and y-coord
    city = values + [False]  # Append visited flag
    cities.append(city)

# Define a list of starting cities
starting_cities = range(len(cities))

# Initialize variables to store the best tour and distance found
best_tour = None
best_distance = float("inf")

start = timer()
if len(cities) < 500:
    # Apply Nearest Neighbor algorithm for each starting city
    for start_city in starting_cities:
        initial_tour = nearest_neighbor(cities, start_city)
        optimized_tour, optimized_distance = two_opt(cities, initial_tour)

        if optimized_distance < best_distance:
            best_tour = optimized_tour
            best_distance = optimized_distance
elif len(cities) < 3000:
    # Calculate the centroid of all cities
    x_sum = sum(city[1] for city in cities)
    y_sum = sum(city[2] for city in cities)
    centroid_x = x_sum / len(cities)
    centroid_y = y_sum / len(cities)

    # Find the city that has the closest coordinates to the centroid
    closest_city_index = min(
        range(len(cities)),
        key=lambda i: compute_distance(cities[i], (None, centroid_x, centroid_y)),
    )

    # Choose the city with the closest coordinates to the centroid as the starting city
    starting_city = cities[closest_city_index]
    starting_city_index = closest_city_index

    # Apply the nearest neighbor algorithm for the selected starting city
    initial_tour = nearest_neighbor(cities, starting_city_index)
    optimized_tour, optimized_distance = two_opt(cities, initial_tour)

    # Update the best tour and distance if the optimized distance is smaller
    best_tour = optimized_tour
    best_distance = optimized_distance
else:
    # Apply the nearest neighbor algorithm for the selected starting city
    initial_tour = nearest_neighbor(cities, 0)
    optimized_tour, optimized_distance = two_opt(cities, initial_tour)

    # Update the best tour and distance if the optimized distance is smaller
    best_tour = optimized_tour
    best_distance = optimized_distance

end = timer()
interval = end - start

print("Time interval =", interval)
print("Best tour:", best_tour)
print("Best distance:", best_distance)

# Write the output to the file
with open("test-output-1.txt", "w") as output_file:
    output_file.write(str(best_distance) + "\n")
    for city in best_tour:
        output_file.write(str(city) + "\n")

# Extract the coordinates of cities in the best tour
"""tour_cities = [cities[city] for city in best_tour]

# Extract the x and y coordinates separately
x_coords = [city[1] for city in tour_cities]
y_coords = [city[2] for city in tour_cities]

# Add the starting city to complete the loop
x_coords.append(tour_cities[0][1])
y_coords.append(tour_cities[0][2])

# Plot the tour
plt.plot(x_coords, y_coords, marker="o", linestyle="-", color="blue")

# Add labels to the cities
for i, city in enumerate(tour_cities):
    plt.text(city[1], city[2], str(i), color="red")

# Set plot title and labels
plt.title("Best Tour")
plt.xlabel("X")
plt.ylabel("Y")

# Show the plot
plt.show()"""
